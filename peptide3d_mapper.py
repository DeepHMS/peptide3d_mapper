# -*- coding: utf-8 -*-
"""Peptide3D Mapper-launch-app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Mrv-OwGk52XP3YA8zQ-IZwV2vIA5cTTH
"""

import streamlit as st
import pandas as pd
import numpy as np
from Bio import SeqIO
import py3Dmol
import io
import requests
from matplotlib import colormaps
from matplotlib.colors import Normalize
import matplotlib.pyplot as plt
from matplotlib.cm import ScalarMappable

def z_score(intensities):
    log_int = np.log10(intensities + 1)
    mean_log = np.mean(log_int)
    std_log = np.std(log_int)
    if std_log == 0:
        return np.zeros_like(log_int)
    else:
        return (log_int - mean_log) / std_log

def map_peptides_to_residues(df, protein_seq, intensity_col, overlap_strategy='merge'):
    if 'Stripped.Sequence' not in df.columns or 'Protein.Group' not in df.columns:
        raise ValueError("CSV must have 'Stripped.Sequence' and 'Protein.Group' columns.")

    seq_len = len(protein_seq)
    residue_vals = [None] * seq_len

    peptides = df.groupby('Stripped.Sequence')[intensity_col].mean().reset_index()
    z_scores = z_score(peptides[intensity_col])

    for idx, row in peptides.iterrows():
        pep = row['Stripped.Sequence']
        start = protein_seq.find(pep)
        if start == -1:
            continue
        end = start + len(pep)
        for i in range(start, end):
            if residue_vals[i] is None:
                residue_vals[i] = [z_scores[idx]]
            else:
                residue_vals[i].append(z_scores[idx])

    for i in range(seq_len):
        if residue_vals[i]:
            residue_vals[i] = np.mean(residue_vals[i])
        else:
            residue_vals[i] = None
    return residue_vals

def generate_colormap(residue_vals, cmap_name='autumn'):
    cmap = colormaps[cmap_name]
    vals = [v for v in residue_vals if v is not None]
    vmin, vmax = (min(vals), max(vals)) if vals else (0, 1)
    hex_colors = []
    for val in residue_vals:
        if val is None:
            hex_colors.append('#d3d3d3')
        else:
            norm = (val - vmin) / (vmax - vmin) if vmax > vmin else 0.5
            rgb = cmap(norm)[:3]
            from matplotlib.colors import rgb2hex
            hex_colors.append(rgb2hex(rgb))
    return hex_colors, vmin, vmax

def render_viewer(pdb_str, residue_vals, bg_color, title):
    hex_colors, vmin, vmax = generate_colormap(residue_vals)
    view = py3Dmol.view(width=400, height=400)
    view.addModel(pdb_str, 'pdb')
    view.setBackgroundColor(bg_color)
    view.setStyle({}, {'cartoon': {'color': 'lightgray'}})
    for i, c in enumerate(hex_colors):
        view.setStyle({'resi': str(i+1)}, {'cartoon': {'color': c}})
    view.zoomTo()

    st.markdown(f"#### {title}")
    st.components.v1.html(view._make_html(), height=420)

    # Show colorbar
    fig, ax = plt.subplots(figsize=(4, 0.5))
    norm = Normalize(vmin=vmin, vmax=vmax)
    sm = ScalarMappable(cmap=colormaps['autumn'], norm=norm)
    cbar = plt.colorbar(sm, cax=ax, orientation='horizontal')
    cbar.set_label(f'{title} Z-score')
    plt.close(fig)  # Clean up
    st.pyplot(fig)

# ------------------------
# Streamlit App
# ------------------------

# Header with icon and title
col1, col2 = st.columns([1, 4])
with col1:
    st.image("icon.png", width=50)  # Small icon; adjust path if needed
with col2:
    st.title("Peptide3D Mapper")

st.markdown(
    """
    <p style='text-align: justify; font-size: 16px; color: #4a4a4a;'>
    A simple, robust web-based tool designed to map peptide data from proteomics experiments to 3D protein structures,
    enabling visualization of peptide intensity profiles for deeper insights into protein behavior.
    </p>
    """,
    unsafe_allow_html=True
)

csv_file = st.file_uploader("Upload Peptide CSV", type=["csv"])
fasta_file = st.file_uploader("Upload FASTA", type=["fasta"])

if csv_file and fasta_file:
    try:
        df = pd.read_csv(csv_file)
    except Exception as e:
        st.error(f"Error reading CSV: {e}")
        st.stop()

    fasta_str = fasta_file.getvalue().decode("utf-8")
    fasta_handle = io.StringIO(fasta_str)
    fasta_records = list(SeqIO.parse(fasta_handle, "fasta"))

    intensity_cols = [c for c in df.columns if 'intensity' in c.lower()]
    if not intensity_cols:
        st.error("No intensity columns found in CSV.")
        st.stop()

    condition1_col = st.selectbox("Select Condition 1 Column", intensity_cols)
    condition2_col = st.selectbox("Select Condition 2 Column", [c for c in intensity_cols if c != condition1_col])

    protein_options = sorted(df['Protein.Group'].unique())
    selected_protein = st.selectbox("Select Protein", protein_options)

    bg_color = st.selectbox("Background Color", ["white", "black", "darkgrey"], index=1)

    protein_seq = None
    for rec in fasta_records:
        if rec.id.startswith(selected_protein.split('-')[0]):  # More precise: match UniProt prefix
            protein_seq = str(rec.seq)
            break

    if protein_seq is None:
        st.error("Protein sequence not found in FASTA. Ensure IDs match (e.g., UniProt prefix).")
        st.stop()
    else:
        df_protein = df[df['Protein.Group'].str.contains(selected_protein, na=False)]
        if df_protein.empty:
            st.error("No peptides found for selected protein.")
            st.stop()

        residues_condition1 = map_peptides_to_residues(df_protein, protein_seq, condition1_col)
        residues_condition2 = map_peptides_to_residues(df_protein, protein_seq, condition2_col)

        base_id = selected_protein.split('-')[0]
        pdb_url = f"https://alphafold.ebi.ac.uk/files/AF-{base_id}-F1-model_v4.pdb"
        with st.spinner("Fetching AlphaFold structure..."):
            try:
                r = requests.get(pdb_url, timeout=10)
                if r.status_code == 200:
                    pdb_str = r.text
                else:
                    raise ValueError(f"PDB fetch failed: {r.status_code}")
            except Exception as e:
                st.error(f"Failed to fetch PDB: {e}. Try a valid UniProt ID or upload a local PDB.")
                st.stop()

        # Render if data available
        condition1_vals = [v for v in residues_condition1 if v is not None]
        condition2_vals = [v for v in residues_condition2 if v is not None]

        if not condition1_vals:
            st.error("No mapped peptides for Condition 1.")
        elif not condition2_vals:
            st.error("No mapped peptides for Condition 2.")
        else:
            col1, col2 = st.columns(2)
            with col1:
                render_viewer(pdb_str, residues_condition1, bg_color, "Condition 1")
            with col2:
                render_viewer(pdb_str, residues_condition2, bg_color, "Condition 2")